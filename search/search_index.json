{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>DIDComm is an open protocol for decentralized communication. It uses DIDs (Decentralized Identifiers) to establish confidential, ongoing connections, without the need for usernames and passwords. You can then layer on existing services and applications on top of DIDComm to take advantage of DIDComm's security and privacy.</p> <p>DIDComm empowers end users with privacy-focused solutions by default, while still retaining flexibility and ease of implementation for developers.</p>"},{"location":"#for-decision-makers","title":"For decision makers","text":"<p>With DIDComm, you keep your options open. It can work alongside OpenID4VC. It enables features you\u2019re likely to need, such as trustable, ongoing connections\u2014if not now, then in the future. - Deliver on privacy promises: connections are established without the need to \u201cphone home\u201d, and the connections are direct and encrypted without involving a middleman. - Use DIDComm connections for identity proofing, messaging, verifiable credential exchanges, and more. - Choose from many flexible solutions for human-to-human or human-to-business interactions.</p>"},{"location":"#for-developers","title":"For developers","text":"<p>DIDComm developer benefits include:</p> <ul> <li>Open standards protocol, continually improved by an active community.</li> <li>Fully decentralized with no central infrastructure or control.</li> <li>Transport independent: supports https, websockets, bluetooth, and more.</li> <li>Works well with related technologies, including blockchain, KERI, verifiable credentials, etc.</li> </ul> <p>See the Quick Start guide for developers, or browse the protocols available to use.</p>"},{"location":"#applications","title":"Applications","text":"<p>See the applications of DIDComm for:</p> <ul> <li>Verifiable Credentials</li> <li>Human communication.</li> </ul>"},{"location":"#community","title":"Community","text":"<p>Join the DIDComm User Group.</p>"},{"location":"#background","title":"Background","text":"<p>Decentralized Identifiers (DIDs) are a type of identifier that enables verifiable, decentralized digital identity. DIDs can refer to any subject, such as a person, organization, thing, data model, and more.</p> <p>DIDComm uses DIDs to bring the benefits of decentralization and confidentiality to many types of communication.</p> <p>Other secure communication solutions already exist. However, most rely on centralized approaches such as server-based architectures with the requirements for hosted components. Many are only for unstructured chat, or enable features through proprietary extensions. They may also assume a single transport (e.g. https), making it difficult to use in a range of situations.</p> <p>DIDComm fixes these problems. It delivers a foundation of security, privacy, and decentralization. It works over https, websockets, bluetooth, and other transports. Any DIDComm protocols you use, for messaging to verifiable credentials and more, automatically inherit these benefits.</p> <p>Applications of DIDComm include online identities, creating and maintaining relationships, buying and selling, scheduling events, negotiating contracts, issuing licenses and permits, presenting tickets for travel, applying to employers or schools or banks, arranging healthcare, playing games, and voting.</p> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#message-authentication","title":"Message Authentication","text":"<p>TODO: Add details about authenticated encryption.</p> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"business_applications/","title":"Business Applications","text":"<p>TODO</p>"},{"location":"developing_protocols/","title":"Developing Protocols","text":"<ul> <li>Implementing a protocol</li> <li>Designing your own protocol</li> <li>When this makes sense</li> <li>Conventions</li> <li>Best practices</li> <li>Sharing your protocol</li> <li>Co-protocols</li> </ul> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"didrotation/","title":"Didrotation","text":""},{"location":"didrotation/#did-rotation","title":"DID Rotation","text":"<p>DIDComm Messaging relies on the DIDs, and associated DID Documents, of the two peers involved in the communication. Those parties are responsible to secure their keys by performing rutinely key rotations, even if they are not compromised, and to make other changes in the DID Documents as needed, such as service endpoints. DIDComm has no involvement in that procedure that is particular to each DID method; nevertheless and provided that the DID does not change, the communication can keep flowing normally.</p> <p>However there are cases when the DID (not the DID Document) need to be rotated by one of the parties, such as in the following three cases: 1. At the beginning of a connection: its common that the initial message is in the form of an Out of Band message that it is unencrypted per definition, and may be observed by another party or transmitted in an unsecure channel such as a QR code or a URL posted in an email or webpage. The DID used in the OOB should be considered as a temporal DID just to start the conversation, but it is highly recommended that it is rotated afterwards to improve privacy. 2. When keys inside a DID Document need to be rotated and the DID method does not allow updating the DID Document with new rotated keys, as is the case for did:key. 3. If there is a need to move to a different DID method for whatever reason (security, flexibility, interoperability, etc)</p> <p>DIDComm defines a specific header to handle DID rotation. This header is called <code>from_prior</code> and can be used in any message sent to the other party. That message must include the <code>from_prior</code> header that is a standard JWT token conformed with: - Header:   - <code>typ</code>: <code>jwt</code>   - <code>alg</code>: verification algorithm such as <code>EdDSA</code>   - <code>crv</code>: curve name   - <code>kid</code>: key id from previous DID that is used in the signature of this JWT - Payload:   - <code>sub</code>: the new DID   - <code>iss</code>: the previous DID   - <code>iat</code>: datetime in seconds - Signature: from the previous DID and key defined in the <code>kid</code></p> <p>Once a DIDComm agent receives a message from an unknown DID, it must: 1. check if there\u2019s a <code>from_prior</code> header 2. if exists, extract the DID from the <code>iss</code> and validate if it matches a known DID 3. validate JWT signatures using the key defined in <code>kid</code> and extracted from previous DID defined in <code>iss</code> 4. if all validations are successful, the new DID should be stored for future communications with the previously known agent</p> <p>The sender, who's doing the rotation, should continue to send the rotation header until they receive a message from the other party using the new DID. This allows for continuity even if one party is offline or not processing messages for a while.</p> <p>Example code showing a DID Rotation after an Out of Band message can be found in the section Starting, using and ending a DIDComm connection from this Guidebook.</p> <p>Since DIDComm is asynchronous in nature, messages can arrive in different order. Sender and receiver should take care to: - Sender: avoid starting a DID rotation in the middle of multiple message conversations. If DID rotation arrives out of order, some messages may be discarded by the recipient. - Receiver: messages received from the old DID but after the message that performs the DID rotation must be discarded to reduce the risk of potentially compromised keys.</p> <p>Finally, DID rotation allows a special case when rotating to nothing that denotes the end of the relationship. In this case the DID should be omitted from the <code>from</code> header and from the <code>sub</code> field of the <code>from_prior</code> header.</p>"},{"location":"extensions/","title":"Extensions","text":""},{"location":"extensions/#extensions","title":"Extensions","text":"<p>Extension adds a self-contained set of conventions or features. Support for them is optional. The following is a list of available extensions. Note that we are in the process of formalizing the status of each extension specification, they should be treated as DRAFT for the moment:</p> <ul> <li>Advanced Sequencing</li> <li>Email Transport</li> <li>L10n</li> <li>Return-Route and Queue Transport</li> </ul>"},{"location":"faq/","title":"Intro","text":"<p>This file will work as a lightweight frequently asked questions before it grows into something unmanagable and needs to have better structure on it. For now this will offer a simple content adressing list an link to each question. We have sections of questions and questions underneath each section. They link directly to each question.</p>"},{"location":"faq/#cryptography","title":"Cryptography","text":"<ol> <li>How kosher is it to do non encrypted messages? </li> </ol>"},{"location":"faq/#misconceptions","title":"Misconceptions","text":"<ol> <li>Does using DIDComm require rip-and-replace strategies?</li> </ol>"},{"location":"faq/#how-kosher-is-it-to-do-non-encrypted-messages","title":"How kosher is it to do non encrypted messages?","text":"<p>Since it is an option to not encrypt DIDComm messages, and we want to be clear on how you can reason about it</p> <p>The answer to \"how kosher\" depends on two subquestions:</p> <ol> <li> <p>Are you uninterested in confidentiality because the message is intended to be public anyway (e.g., it's a message inviting anyone in the general public to send you a message)?</p> </li> <li> <p>Will the message stay within trust domain boundaries? (That is, Alice sends an encrypted message to Bob; Bob decrypts and wants to send it as plaintext to 5 of his agents, but all of them are within his own sphere of control, and Bob trusts himself.)</p> </li> </ol> <p>If the answer to either of these questions is \"Yes\", then we think non encrypted messages are completely fine.</p> <p>If the answer to both of these questions is \"No\", then we think messages should be encrypted, because it means confidentiality should matter. It might be tempting to say, \"True. But I'm using https, which gives confidentiality anyway.\" This is a fallacy, because by design a sender in DIDComm doesn't actually know the full route to the target. A sender might be using HTTPS, but perhaps part of the route is not. Using channel-oriented encryption (e.g., TLS) on the part of the channel you can see is not actually secure, if someone somewhere has to take plaintext off that channel and put it somewhere else that you don't know about. The guarantee is supposed to be end-to-end. (In our question #2 above, \"Bob\" is the end; what he does after it gets to him is his business, not DIDComm's. That's why we are comfortable with him using plaintext in a context wholly under his own control.)</p>"},{"location":"faq/#does-using-didcomm-require-rip-and-replace-strategies","title":"Does using DIDComm require rip-and-replace strategies?","text":"<p>This misperception seems to originate from a misunderstanding about how DIDcomm works. </p> <p>Any web server capable of receiving a POST request, and sending a POST request, is capable of sending and receiving encrypted DIDComm messages. Libraries exist for message decryption, and processing inbound messages is not particularly different than processing a web request. Further libraries or software packages may add additional functionality, but the fundamentals can be enabled with very few changes to existing web properties.</p> <p>DIDComm protocols also co-exist nicely with other protocols common in the Decentralized Identity space, including VC-API and OID4VCs. There is no technical reason why more than one of these protocols cannot be supported within the same system.</p> <p>DIDComm builds on this basic ability to pass messages between parties to provide something deliberately different in architecture. DIDComm is a message based protocol, designed specifically to be friendly to the devices in most common use by humans. This includes built in message routing that allows human oriented devices as well as enterprise participants. This architectural model allows for interactions to be initiated be either party, allowing a much richer interaction model than API based approaches.</p> <p>If native support of DIDComm isn't your goal, than you can easily use one of several codebases that support DIDComm and offer HTTP APIs for backend integration, handling not only DIDComm, but credential and other interactions as well.</p> <p>In short, it easily augments any web infrastructure, provides a rich interaction model that goes beyond API approaches, and does not require removal of any existing infrastructure, systems, or protocol support.</p>"},{"location":"general_concepts/","title":"General Concepts","text":"<p>TODO</p> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"helloencrypt/","title":"Build DIDComm messages","text":""},{"location":"helloencrypt/#encrypted-didcomm-message","title":"Encrypted DIDComm message","text":"<ul> <li>JVM</li> <li>Python</li> <li>RUST</li> </ul>"},{"location":"helloencrypt/#unencrypted-but-signed-didcomm-message","title":"Unencrypted but signed DIDComm message","text":"<ul> <li>JVM</li> <li>Python</li> <li>RUST</li> </ul>"},{"location":"helloencrypt/#plaintext-didcomm-message","title":"Plaintext DIDComm message","text":"<ul> <li>JVM</li> <li>Python</li> <li>RUST</li> </ul>"},{"location":"hellolibstools/","title":"Choosing libraries and tools","text":"<p>This is a list of libraries and tools available to DIDComm developers.</p> <p>Much of this information comes from this IIW presentation and slides.</p>"},{"location":"hellolibstools/#available-releases","title":"Available Releases","text":"<ul> <li>PyPi DIDComm Release</li> <li>PyPi Peer DID Release</li> <li>Maven DIDComm Release</li> <li>Maven Peer DID Release</li> <li>Crate DIDComm Release</li> </ul>"},{"location":"hellolibstools/#reference-implementations","title":"Reference Implementations","text":"<p>These reference implementations provide a demonstration and examples in several programming languages.</p> <ul> <li>Python<ul> <li>DIDComm Python</li> <li>Peer DID Python</li> </ul> </li> <li>Java, Kotlin, Android <ul> <li>DIDComm Java, Kotlin, Android</li> <li>Peer DID Java, Kotlin, Android</li> </ul> </li> <li>RUST<ul> <li>DIDComm RUST<ul> <li>JavaScript/TypeScript via WASM</li> <li>iOS via wrapper is WIP<ul> <li>other languages can be supported via wrappers</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"hellolibstools/#tools","title":"Tools","text":"<p>DIDComm v2 developers are contributing to projects that provide important tools for DIDComm v2.</p> <ul> <li>ECDH-1PU<ul> <li>JVM<ul> <li>Nimbus Jose JWT</li> </ul> </li> <li>Python<ul> <li>Authlib</li> </ul> </li> <li>Rust<ul> <li>Aries Askar</li> </ul> </li> </ul> </li> <li>DID rotation</li> <li>Forward protocol - Used by default for routing DIDComm messages.</li> <li>Python example</li> <li>Kotlin example</li> <li>RUST example </li> <li>Peer DID<ul> <li>Static layers of support only (similar to did:key method).  But more support for dynamic updates.</li> </ul> </li> </ul>"},{"location":"helloworldpy/","title":"Helloworldpy","text":""},{"location":"helloworldpy/#hello-world-in-python","title":"\"Hello World\" in Python","text":"<p>This simple \"Hello World\" example shows how Alice can create an encrypted message to Bob. In that case, we are using DIDComm Python and Peerdid Python libraries from SICPA.</p>"},{"location":"helloworldpy/#step-1-install-packages","title":"Step 1: Install packages","text":"<p>Once you set up your python environment, you need to install the following packages:</p> <pre><code>pip install didcomm\npip install peerdid\npip install json\n</code></pre> <p>The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook.</p>"},{"location":"helloworldpy/#step-2-imports","title":"Step 2: Imports","text":"<p>First, we need to import all required functions, clases and types from <code>didcomm</code> and <code>peerdid</code> libraries as follows:</p> <pre><code>from didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat\nfrom didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService\nfrom didcomm.did_doc.did_resolver import DIDResolver\nfrom didcomm.message import Message\nfrom didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo\nfrom didcomm.unpack import unpack, UnpackResult\nfrom didcomm.common.resolvers import ResolversConfig\nfrom didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult\nfrom didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret\nfrom peerdid import peer_did\nfrom peerdid.did_doc import DIDDocPeerDID\nfrom peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID\nimport json\n</code></pre>"},{"location":"helloworldpy/#step-3-resolvers","title":"Step 3: Resolvers","text":"<p>In this step we add two Resolvers needed by DIDComm and the libraries:</p> <p>Secret resolver:</p> <p>This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a <code>secrets_resolver</code>. We can instantiate it as follows: <code>secrets_resolver = SecretsResolverDemo()</code> Note that the <code>SecretsResolverDemo</code> simply stores the keys in a text file named <code>secrets.json</code>. As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production.</p> <p>DID Resolver:</p> <p>DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick.</p>"},{"location":"helloworldpy/#step-4-create-dids","title":"Step 4: Create DIDs","text":"<p>Using <code>create_simple_peer_did</code> helper function, Alice and Bob can create their DID Peer that they will share and use when communicating privately between each other. This function creates a basic DID Peer with only one Agreement key, one Authentication key, and no Service part. You can find the helper function and the full code here. </p> <pre><code>alice_did = await create_simple_peer_did()\nprint(\"Alice's DID:\", alice_did)\nbob_did = await create_simple_peer_did()\nprint(\"Bob's DID:\", bob_did)\n</code></pre> <p>You should get something similar to:</p> <pre><code>Alice's DID: did:peer:2.Ez6LSt4Jscr227NFyuzKHT85haVE4AFVXm1tDwYeZ5xenxMmW.Vz6MkfvwnoNS6Cto38MEMbqdnypVDN7gS4oAMaHFkjAUse5JE\nBob's DID: did:peer:2.Ez6LSetXDUvD8rBSei5TU5ew7VRdWyNBr5mAsxr6EoHFTxt9f.Vz6Mkty3Nu98rnrHfk1GBCurF7EFKY5Vb34FAJNJCMhwzduk3\n</code></pre> <p>Remember that while creating these simple DIDs, our helper function also stores the private keys in the <code>secrets_resolver</code>. In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet. Also, those Peer DIDs can be resolved into DID documents that contain the Authentication and Agreement public keys.</p>"},{"location":"helloworldpy/#step-5-encrypt-and-pack-the-message","title":"Step 5: Encrypt and pack the message","text":"<p>Alice can create a simple \"Hello World\" message with:</p> <pre><code>message = Message(\n    body = {\"msg\": \"Hello World\"},\n    id = \"unique-id-24160d23ed1d\",\n    type = \"my-protocol/1.0\",\n    frm = alice_did,\n    to = [bob_did]\n)\n</code></pre> <p>Note that the message includes an <code>id</code> that is mandatory and has to be unique to Alice. Also includes a <code>type</code>, also mandatory, that points to the protocol identifier that we've just invented. The <code>body</code> contains the actual message in an structured way associated by our <code>my-protocol/1.0</code>. Attributes <code>from</code> and <code>to</code> are optional. Beware that in the code above the property <code>from</code> was replaced by <code>frm</code> due to a conflict of reserved words in Python; the conversion to the correct property (<code>from</code>) is handled internally by the library.</p> <p>DIDComm defines three message formats: plaintext, signed, and encrypted. We are going to use the latter since it is the most common for most applications. In that case, the message will be encrypted so only Bob can see it. The final packed message can be generated with this code:</p> <pre><code>packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = message,\n    frm = alice_did,\n    to = bob_did,\n    sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n</code></pre> <p>This library also offers the option of anonymous encryption, encryption with no repudation, and message signing. Note also that we pass a resolver configuration pointing to our secrets store and the DID resolver. If you take a look at the packed message, you'll see that the content was hidden in the encryption:</p> <pre><code>print(packed_msg.packed_msg[:200]+\"...\")\n</code></pre> <p><code>{\"protected\":\"eyJ0eXAiOiJhcHBsaWNhdGlvbi9kaWRjb21tLWVuY3J5cHRlZCtqc29uIiwiYWxnIjoiRUNESC0xUFUrQTI1NktXIiwiZW5jIjoiQTI1NkNCQy1IUzUxMiIsImFwdSI6IlpHbGtPbkJsWlhJNk1pNUZlalpNVTNJM1pWaFlObXBxYjI0MFpFVmFWaz...</code></p>"},{"location":"helloworldpy/#step-6-receive-and-unpack-the-message","title":"Step 6: Receive and unpack the message","text":"<p>Alice will send the packed message to Bob using a transport. Once received, Bob can unpack it with the following code:</p> <pre><code>unpack_msg = await unpack(\n    resolvers_config=ResolversConfig(\n        secrets_resolver=secrets_resolver,\n        did_resolver=DIDResolverPeerDID()\n    ),\n    packed_msg=packed_msg.packed_msg\n)\n</code></pre> <p>Note that we also passed the resolver config as before. Finally, Bob can see Alice's message by:</p> <pre><code>print(unpack_msg.message.body[\"msg\"])\n</code></pre> <p><code>Hello World</code></p>"},{"location":"libraries/","title":"Libraries","text":""},{"location":"libraries/#didcomm-libraries","title":"DIDComm Libraries","text":"<ul> <li>Python<ul> <li>DIDComm Python</li> </ul> </li> <li>Java, Kotlin, Android <ul> <li>DIDComm Java, Kotlin, Android</li> </ul> </li> <li>RUST<ul> <li>DIDComm RUST<ul> <li>JavaScript/TypeScript via WASM</li> <li>iOS via wrapper is WIP<ul> <li>other languages can be supported via wrappers</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"libraries/#peer-did-libraries","title":"Peer DID Libraries","text":"<p>Peer DIDs are a commonly used DID method to use with DIDComm. The following libraries can be used for Peer DID support.</p> <ul> <li>Python<ul> <li>Peer DID Python</li> </ul> </li> <li>Java, Kotlin, Android <ul> <li>Peer DID Java, Kotlin, Android</li> </ul> </li> </ul> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"migratorscript/","title":"V1 --&gt; v2 migrator script","text":""},{"location":"migratorscript/#header-and-decorator-mappings","title":"Header and decorator mappings","text":"v1 v2 Notes @id id @type type ~thread.thid thid ~thread.pthid pthid ~thread.sender_order sender_order see Advanced Sequencing Extension ~thread.received_orders received_order see Advanced Sequencing Extension ~thread.goal_code body.goal_code goal_code body.goal_code goal body.goal ~l10n l10n see L10n Extension ~transport.return_route return_route see Return-Route Extension ~timing.expires_time expires_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z sent_time created_time v1 use timestamp format as \"2019-01-25 18:25Z\", v2 use unixtime seconds since 1970-01-01T00:00:00Z handler handler ~trace trace ~attach attachments an array of attachments ~attach[n].@id attachments[n].id ~attach[n].mime_type attachments[n].media_type ~attach[n].filename attachments[n].filename ~attach[n].description attachments[n].description ~attach[n].lastmod_time attachments[n].lastmod_time ~attach[n].byte_count attachments[n].byte_count ~attach[n].filename attachments[n].filename ~attach[n].data attachments[n].data ~attach[n].data.jws attachments[n].data.jws ~attach[n].data.sha256 attachments[n].data.hash ~attach[n].data.links attachments[n].data.links ~attach[n].data.base64 attachments[n].data.base64 ~attach[n].data.json attachments[n].data.json problem_code body.code in Problem Report Protocol comment body.comment in Problem Report Protocol"},{"location":"mitm/","title":"Mitm","text":""},{"location":"mitm/#didcomm-and-man-in-the-middle","title":"DIDComm and Man-in-the-Middle","text":"<p>(Content to be added here. See https://j.mp/3BzImtr)</p>"},{"location":"mobileagents/","title":"Dealing with mobile agents","text":"<p>Mobile agents are a key component in many decentralized identity solutions. Individuals holding Identity Wallets on their mobile phones, and IoT devices transmitting secure information from remote locations are some common examples of mobile agents. The ability to roam from different networks and change connectivity seamlessly is a great feature. However it comes at the expense that agents are unable to declare a unique network address where to be reached. Also, that obstacle becomes more complex when agents are hidden inside network firewalls.</p> <p>Additionally, DIDComm Messaging specifies that: * Transports are simplex, they only transfer messages from sender to receiver. No information about the effects or results from a message is transmitted over the same connection. * Parties may declare a <code>serviceEndpoint</code> in their DID Document. However DID Documents are mainly static and updating them, if possible, is not an instant process.</p> <p>Given the above mentioned situation, the question is how a mobile agent can receive a DIDComm message</p> <p>The answer is  Routing Protocol 2.0, that can be also complemented by the Return-Route extension.</p>"},{"location":"mobileagents/#routing-protocol","title":"Routing Protocol","text":"<p>The Routing Protocol defines a partially trusted party called Mediator to facilitate message delivery. Senders can pass messages to a mediator, so next, the mediator can forward them to the final destination. Of course, the final message to the receiver is encrypted and obscured to the intermediate mediator or mediators.</p> <p></p> <p>Message from the sender to the mediator is of type <code>forward</code> and contains the encrypted messages to the receiver as <code>attachments</code> . Also, by this means, recipients can declare a mediator's <code>serviceEndpoint</code> as its own <code>serviceEndpoint</code> to receive messages.</p>"},{"location":"mobileagents/#return-route","title":"Return Route","text":"<p>Althougt not fully necessary to solve the mobile agent problem, the Return-Route extension facilitates the communication by enabling bi-directional communication on the same transport, even when one party has no public endpoint. Messages can flow back in response to inbound messages over the same connection. That means that if the <code>return-route</code> header is present in a message with a value different to <code>none</code>, the receiver of a message can reply back in the same channel that was already established without the need to expose an endpoint.</p>"},{"location":"mobileagents/#solution-via-mediator","title":"Solution via Mediator","text":"<p>With those two elements a solution can be developed to cope with our problem. The process can be described as follow: 1. The mobile agent sends a message to register to a Mediator following a predefined protocol called Mediator Coordinator Protocol. The message must contain the <code>return-route</code> header. 2. The Mediator responds back to the mobile agent in the same channel that was already opened in the first step. In the response, the mediator assigns a own <code>serviceEndpoint</code> to the mobile agent, that later can be used in when sending messages to other parties. 3. Those third parties, when receiving a message from the mobile agent, can respond using the Routing Protocol by sending a <code>forward</code> message to the Mediator that contains the encrypted response to the mobile agent as an attachment. 4. The Mediator should hold the message, since there is no way to pass it to the mobile agent directly. 5. Using a predefined protocol called Pickup Protocol, the mobile agent contacts the Mediator who can respond back in the same channel forwarding all held messages from third parties.</p>"},{"location":"oid4vc/","title":"DIDComm and OpenID for Verifiable Credentials","text":"<p>The OpenID for Verifiable Credentials protocols are focused protocols that follow patterns familiar with uses of the OpenID family of specs. The OID4VC protocols for Issuance and Verification are capable of issuing and presenting credentials of a variety of formats. DIDComm Protocols work very well alongside OID4VC protocols, and we'll explain how.</p>"},{"location":"oid4vc/#verifiable-credentials","title":"Verifiable Credentials","text":"<p>Both sets of protocols are credential type agnostic - they can issue or present credentials of any type. Further, these protocols are capable of presenting credentials issued via the other protocol. Credentials issued via OID4VCI can be presented via DIDComm PresentProof, and vice versa.</p> <p>In addition to cross presentation and issuance, OID4VC users can benefit from the other credential-related features DIDComm provides. DIDComm provides messaging from the Issuer (or Verifier) to the holder without prior interaction. This communication is secure and mobile-device friendly. This enables prompting user action necessary for issuance or presentation in situations where the user is not anticipating the need. DIDComm also has a Revocation Notification protocol that allows the Issuer to notify the Holder that an issued credential has been revoked. This can smooth a user experience and prevent the presentation of a revoked credential, or facilitate the reissuance of replacement.</p> <p>DIDComm protocols exist for many features beyond Verifiable Credentials. The next section includes notes about human oriented communication, which can often be used in concert with VC protocols to explain credential or business process details using longer explanations.</p>"},{"location":"oid4vc/#human-communication","title":"Human Communication","text":"<p>DIDComm has protocols for Messaging, Question &amp; Answer, and even a basic menu behavior. These protocols can augment the experience of Verifiable Credential exchange, but can also be used to leverage the trust gained from VC exchange into other activities. Sending notifications, checking confirmations, and asking questions are all things easily accomplished with existing protocols.</p>"},{"location":"oid4vc/#all-didcomm-protocols","title":"All DIDComm Protocols","text":"<p>DIDComm Protocols are easy to create for any purpose. Secure interaction is easy to facilitate, and DIDComm protocols help supply that functionlity.</p>"},{"location":"oid4vc/#whats-required","title":"What's required?","text":"<p>In order to turn an OID4VC interaction into a DIDComm connection, the OID4VC exchange must include a DID that contains a DIDComm service endpoint, or can be updated to include a DIDComm Service Endpoint. Ideally, both parties share their DID in the exchange, allowing either to initiate a DIDComm relationship.</p> <p>And that's it. Knowing the other party's DID and resolving the DID Document to find the DIDComm Service Endpoint enables you to engage in any of the supported DIDComm Protocols, including presenting credentials and more.</p>"},{"location":"pfs/","title":"Pfs","text":""},{"location":"pfs/#perfect-forward-secrecy","title":"Perfect Forward Secrecy","text":"<p>A cryptographic method exhibits perfect forward secrecy (PFS) if the compromise of long-term keys does not allow an attacker to read old messages. The secrecy of the old messages persists forward in time. See the Wikipedia article, and also section 6.2 of this academic article. This property is valuable to the extent that comm channels are long-lasting and carry many interactions.</p> <p>DIDComm does not achieve this property under the familiar definition, because it lacks a session construct that defines how to interpret a phrase like \"long-term keys\" and \"session keys.\" Whether DIDComm achieves comparable goals is perhaps more interesting.</p> <p>In TLS, session keys are symmetric keys negotiated during a Diffie-Hellman handshake at the beginning of a series of request-response interactions that cluster together. Browsers running HTTPS \u2014 the most familiar embodiment of TLS \u2014 typically do a new DH exchange each time a tab is opened to a site's initial page, but not for subsequent requests to fetch graphics, scripts, CSS files, or the content and collateral of subsequent pages. Cryptographic sessions (not to be confused with cookie-based login sessions) may be re-established whenever a socket is re-opened (possibly at intervals only a few seconds apart), or may use techniques like TLS Session Resumption to last for hours or even days.</p> <p>A simple analysis of DIDComm might map PFS \"session keys\" to the ephemeral symmetric keys negotiated by the ECDH-1PU key agreement algorithm; this might imply that the static keys in Alice's DID doc would be the \"long-term keys\" from the PFS definition. In this framing, DIDComm does NOT exhibit PFS, because an attacker that possesses a key from Alice's DID doc can decrypt any old messages sent to that key.</p> <p>But this analysis misses two important insights:</p> <ol> <li> <p>The ephemeral symmetric keys in TLS are two-way and reusable. It makes sense to call them \"session\" keys. In contrast, the ephemeral symmetric keys negotiated by ECDH-1PU in DIDComm are one-way and single-use only. Calling a one-way delivery of a single message a \"session\" seems a bit odd. The natural unit of clustered interaction in DIDComm \u2014 what we use \"sessions\" for in TLS, and what lasts seconds to minutes or hours \u2014 is a single protocol or group of protocols that accomplish one goal for the parties. This is a higher level of abstraction that a single DIDComm message.</p> </li> <li> <p>Only one compromise is contemplated by normal PFS \u2014 the compromise of a single long-term key. But DIDComm is more dynamic. It supports two types of rotation \u2014 rotation of DID doc keys and rotation of DIDs themselves. Moreover, DIDComm supports multiple devices per party, and it encourages the use of pairwise DIDs with a limited lifespan, often not exceeding a single interaction. It is the value of historic communication that makes PFS valuable. If DIDComm throws away DIDs after a single brief interaction, then PFS is irrelevant. If DIDComm rotates DIDs on the same time scales as static key rotation in TLS, then it is a DID's comm history, not Alice's (DID-spanning) comm history, that's endangered by a compromise. And if Alice has a stable DID but updates her DID doc regularly to track an evolving collection of devices, then her vulnerability to long-term key compromise doesn't map very well to the simpler PFS model.</p> </li> </ol> <p>Here are two alternate analyses that suggest DIDComm accomplishes the goals of PFS, even if its approach is unfamiliar. We do NOT advocate these analyses as objectively \"true\" \u2014 they are mutually incompatible, and unless/until formal definitions are satisfied, it is clearly unwise to rely on loose assertions about cryptographic guarantees. Rather, the point of including them here is to illustrate the importance of assumptions. </p>"},{"location":"pfs/#pfs-reframe-1","title":"PFS Reframe 1","text":"<p>In some DIDComm usages, \"sessions\" might have the same scope as DIDs, and \"long-term keys\" might have the same scope as a multi-DID-spanning connection between two parties. A compromise of the second \"long-term key\" (DID and associated keys for all her devices) used by Alice in her relationship with Bob would allow an attacker to read everything sent to Alice in that session (while she was using DID #2). However, it wouldn't let the attacker read anything sent to Alice in the previous sessions (with previous DID values). DIDComm would thus accomplish the same goals as perfect forward secrecy.</p>"},{"location":"pfs/#pfs-reframe-2","title":"PFS Reframe 2","text":"<p>In other DIDComm usages, \"sessions\" might have the same scope as a single snapshot of the key agreement keys in a DID doc, and \"long-term keys\" would be the signing keys that authorize updates to a new set of key agreement keys. A compromise of long-term keys would not allow the attacker to decrypt any historical communication at all. DIDComm would thus accomplish the same goals as perfect forward secrecy.</p> <p>Thus, the guidance on perfect forward secrecy with respect to DIDComm is simple:</p> <p>Understand your goals and your assumptions.</p> <p>Consider questions like these: What is the intended lifespan of a DID in your DIDComm usage patterns? How often are its keys (both encryption and signing) rotated \u2014 and with what purposes?</p> <p>DIDComm allows various answers to these questions; depending on the answers, it may or may not provide enough built-in protection of old communication at the point of a future compromise.</p>"},{"location":"privacy/","title":"Privacy","text":""},{"location":"privacy/#privacy","title":"Privacy","text":"<p>This section discusses best practices and the implications of DIDComm Protocols on the privacy of the communicating parties.</p>"},{"location":"privacy/#public-fingerprinting","title":"Public Fingerprinting","text":"<p>Users should avoid disclosing supported protocols until sufficient trust has been established. The broad disclosure of supported protocols may provide a unique fingerprint that can be used to correlate multiple identifiers in use by a single party.</p> <p>DIDComm's use of the Discover Features Protocol allows selective disclosure of features to mitigate this problem. Leveraging this protocol as a better substitute for Verifiable Data Registry (VDR) published DID Document endpoints will prevent the disclosure of unique protocols.</p>"},{"location":"problemcodes/","title":"Problem Codes","text":"<p>Problems are reported by a specific message defined in the Problem Report 2.0 protocol. That message looks like this:</p> <pre><code>{\n  \"type\": \"https://didcomm.org/report-problem/2.0/problem-report\",\n  \"id\": \"7c9de639-c51c-4d60-ab95-103fa613c805\",\n  \"pthid\": \"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\",\n  \"ack\": [\"1e513ad4-48c9-444e-9e7e-5b8b45c5e325\"],\n  \"body\": {\n    \"code\": \"e.p.xfer.cant-use-endpoint\",\n    \"comment\": \"Unable to use the {1} endpoint for {2}.\",\n    \"args\": [\n      \"https://agents.r.us/inbox\",\n      \"did:sov:C805sNYhMrjHiqZDTUASHg\"\n    ],\n    \"escalate_to\": \"mailto:admin@foo.org\"\n  }\n}\n</code></pre> <p>One of the most important headers of that message is the <code>code</code> header that categorizes, in a machine readable format, what went wrong. <code>code</code> follows a structured format defined in Problem Codes on the specification.</p> <p>In short, the code is contructed as a sequence like: <code>{sorter}.{scope}.{general_descriptor}.{specific_descriptor}.{more_specific_descriptor}..</code></p> <ul> <li><code>{sorter}</code> can be either <code>e</code> it is an error, or <code>w</code> id it is a warning.</li> <li><code>{scope}</code> can be either <code>p</code> if belongs to a protocol, or <code>m</code> if it was triggered by a previous message.</li> <li><code>{descriptors}</code> is a kebab-case sequence of descriptors separated by <code>.</code> where the semantics get progressively more detailed reading left to right.</li> </ul> <p>In this section we are listing a list of predefined codes that can be used by themselves, or as prefixes to more specific descriptors:</p> Token Value of <code>comment</code> string Notes <code>trust</code> Failed to achieve required trust. Typically this code indicates incorrect or suboptimal behavior by the sender of a previous message in a protocol. For example, a protocol required a known sender but a message arrived anoncrypted instead \u2014 or the encryption is well formed and usable, but is considered weak. Problems with this descriptor are similar to those reported by HTTP's <code>401</code>, <code>403</code>, or <code>407</code> status codes. <code>trust.crypto</code> Cryptographic operation failed. A cryptographic operation cannot be performed, or it gives results that indicate tampering or incorrectness. For example, a key is invalid \u2014 or the key types used by another party are not supported \u2014 or a signature doesn't verify \u2014 or a message won't decrypt with the specified key. <code>xfer</code> Unable to transport data. The problem is with the mechanics of moving messages or associated data over a transport. For example, the sender failed to download an external attachment \u2014 or attempted to contact an endpoint, but found nobody listening on the specified port. <code>did</code> DID is unusable. A DID is unusable because its method is unsupported \u2014 or because its DID doc cannot be parsed \u2014 or because its DID doc lacks required data. <code>msg</code> Bad message. Something is wrong with content as seen by application-level protocols (i.e., in a plaintext message). For example, the message might lack a required field, use an unsupported version, or hold data with logical contradictions. Problems in this category resemble HTTP's <code>400</code> status code. <code>me</code> Internal error. The problem is with conditions inside the problem sender's system. For example, the sender is too busy to do the work entailed by the next step in the active protocol. Problems in this category resemble HTTP's <code>5xx</code> status codes. <code>me.res</code> A required resource is inadequate or unavailable. The following subdescriptors are also defined: <code>me.res.net</code>, <code>me.res.memory</code>, <code>me.res.storage</code>, <code>me.res.compute</code>, <code>me.res.money</code> <code>req</code> Circumstances don't satisfy requirements. A behavior occurred out of order or without satisfying certain preconditions \u2014 or circumstances changed in a way that violates constraints. For example, a protocol that books plane tickets fails because, halfway through, it is discovered that all tickets on the flight have been sold. <code>req.time</code> Failed to satisfy timing constraints. A message has expired \u2014 or a protocol has timed out \u2014 or it is the wrong time of day/day of week. <code>legal</code> Failed for legal reasons. An injunction or a regulatory requirement prevents progress on the workflow. Compare HTTP status code <code>451</code>."},{"location":"problems/","title":"Problems","text":""},{"location":"problems/#timeouts","title":"Timeouts","text":"<p>It is a best practice to ponder appropriate timeout settings when designing application-level protocols atop DIDComm. A protocol for conducting live music over the internet should probably time out its messages to cue musicians within milliseconds, whereas a protocol to apply for college may need timeouts that are days or weeks long. A protocol definition should communicate timeout assumptions like these.</p> <p>Individual implementers of a protocol should also ponder whether they need timeouts more aggressive than those of the general community. Perhaps a college application protocol allows the process to unfold over weeks -- but an app that promises it can help someone apply to college in 5 minutes shouldn't use default timeouts in the messages it sends.</p>"},{"location":"problems/#cybersecurity-considerations-for-problem-reports","title":"Cybersecurity considerations for problem reports","text":"<p>Ethical and unethical hackers deliberately trigger errors on systems to understand what exploits are possible. We expect this to happen with DIDComm. Therefore, the troubleshooting and transparency that comes from problem reports needs to be weighed against the risk of disclosing too much information. The following considerations are recommended.</p> <ol> <li>Problem reports do not have to be sent (only) to the party who triggers a problem. Sometimes, a different (or additional) audience may be appropriate.</li> <li>The <code>problem-report</code> message type is deliberately decoupled from the versioning and release status of other protocols, so it cannot be used for feature sniffing.</li> <li>Fields that encourage careless, recursive information dumping (e.g., Java's <code>Throwable.cause</code>) do not appear in <code>problem-report</code>.</li> <li>The <code>comment</code> and <code>args</code> properties of a <code>problem-report</code> are separated, with <code>comment</code> mapping consistently to a <code>code</code>. This means that the risk of disclosing too much information is concentrated in the value of <code>args</code>, not <code>comment</code>. Values placed in <code>args</code> should be scrubbed of anything sensitive.</li> <li>Sending problem reports to an unknown party is more risky than sending them to someone with known characteristics. (Because DIDComm's normal mode is mutual authentication via DIDs, and because DIDComm connections may accumulate credential-based context, this is a manageable risk.)</li> <li>Sending problem reports immediately may be more risky than sending them with a modest, random delay. This makes denial-of-service attacks and temporal correlation harder, and is the same principle that motivates login dialogs to pause before reporting an incorrect password. </li> </ol>"},{"location":"quickstart/","title":"Quick Start","text":"<p>This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.</p> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"repos/","title":"Repositories","text":"<p>The following repositories are relevant to DIDComm:</p> <ul> <li> <p>DIDComm v2 Specification</p> </li> <li> <p>DIDComm.org</p> </li> <li> <p>DIDComm Book</p> </li> </ul> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"routing-old/","title":"Routing old","text":""},{"location":"routing-old/#routing","title":"Routing","text":"<p>Routing is the process of managing the delivery of messages from sender to recipient, possibly adapting the packaging and transfer to intermediate nodes. A route is a map or plan that specifies enough to achieve delivery in at least one direction; it may omit uninteresting details.</p> <p>A sender emits a message hoping that a recipient eventually receives it. As a message moves toward the recipient, we say it is moving destward; the opposite direction is sourceward. Note that sender and recipient flip if a request-like message is followed by a response-like message in the opposite direction; the context that defines a sender is a single message, not a paired interaction. (DIDComm supports request-response but does not require it.)</p> <p>We tend to conceive of senders and recipients as simple \u2014 \"Alice\" and \"Bob\" sound like unitary individuals. This can be a useful simplification. However, it's important to remember that it may hide important detail; if Bob uses a laptop, a mobile device, and a cloud service to receive messages, and if each of them follows the cryptographic best practice of not sharing keys, then it is impossible to ignore this complexity in some parts of routing design. We call the set of things that Bob controls his sovereign domain (or domain for short). Note that this usage is notably different from the meaning of \"domain\" in DNS and many web contexts. We also use the loose cover term agent to refer to individual devices or pieces of software inside a given domain. The boundary of a domain is an important construct for trust analysis and for routing. We will explore this in greater detail below.</p>"},{"location":"routing-old/#routing-requirements","title":"Routing Requirements","text":"<p>All messaging technologies must address routing in some way. However, DIDComm has unusual requirements:</p> <ul> <li> <p>Because of security and privacy goals, DIDComm routing must impose careful limits on how and to what degree intermediate nodes are trusted.</p> </li> <li> <p>Because DIDComm aims to be transport-independent, its routing model must be carefully decoupled from  strong assumptions about networking. In particular, DIDComm routing cannot make broad-brush assumptions that:</p> </li> <li>A given route will use only a single transport.</li> <li>Transport mechanisms will provide any security benefits.</li> <li>The identity and connectivity for every hop in a route will be known by any party at the time a message is sent.</li> <li>The route from sender to recipient will be similar in hop identity, hop count, or transport mix to a complementary route from recipient back to sender.</li> <li> <p>All the nodes in a route are ever online at the same time.</p> </li> <li> <p>Because of decentralization and multiple-peer-friendly goals, DIDComm routing cannot orient itself around servers or simple request\u2014response patterns as mandatory components.</p> </li> <li> <p>Because of privacy goals, DIDComm must offer fine distinctions in how repudiation and authentication are handled.</p> </li> </ul> <p>These requirements are very demanding. They do NOT necessarily make DIDComm hard to implement. They do NOT prevent DIDComm from using common web infrastructure \u2014 indeed, DIDComm routes quite simply and elegantly over HTTP. However, they DO force the routing model to be described in a very generic, flexible way, and they DO mean that existing routing solutions are an imperfect fit. DIDComm learns as much as it can, and borrows as much as it can, from clever and battle-tested routing work done in other contexts, but it does have some unique twists.</p>"},{"location":"routing-old/#overview","title":"Overview","text":"<p>Let's focus on a simple case where <code>A</code> wants to send a message to <code>B</code>, and the route involves one intermediate hop at <code>C</code>. Suppressing a few details, DIDComm routing works like this:</p> <ol> <li><code>A</code> prepares a plaintext message of any type, <code>M[0]</code>, and encrypts it for the recipient, <code>B</code>. This produces <code>M[1]</code>.</li> <li>A prepares another plaintext message of type <code>forward</code>, and adds <code>M[1]</code> to it as an attachment. This new message, <code>M[2]</code>, asks <code>C</code> to to deliver the attached payload to <code>B</code>. <code>A</code> encrypts <code>M[2]</code> for <code>C</code>, producing <code>M[3]</code>.</li> <li><code>A</code> hands <code>M[3]</code> to <code>C</code>.</li> <li><code>C</code> decrypts <code>M[3]</code>, producing <code>M[2]</code>. Reading the plaintext, <code>C</code> sees that it's been asked to deliver the encrypted attachment to <code>B</code>.</li> <li><code>C</code> hands the attachment from <code>M[2]</code> \u2014 which is the encrypted message <code>M[1]</code> \u2014 to <code>B</code>.</li> <li><code>B</code> decrypts <code>M[1]</code>, reproducing the plaintext <code>M[0]</code>.</li> </ol> <p></p> <p>This is not the simplest possible scenario; DIDComm could be direct from <code>A</code> to <code>C</code>, which would eliminate steps 2-5. Some DIDComm+HTTP interactions are that simple. And it is not the most complex DIDComm routing scenario, either. Much more elaborate routes could be described by introducing additional hops with additional <code>forward</code> messages. However, the above sequence is a good rough model to carry through the discussion that follows.</p>"},{"location":"routing-old/#the-forward-message","title":"The <code>forward</code> message","text":"<p>The <code>forward</code> message created in step 2 in our overview is a DIDComm application-level protocol message. Routing, as described here, is just one of many protocols that can be built atop DIDComm primitives. A and C are \"speaking\" this protocol when they communicate. The routing protocol can use the same features as any other application-level protocol; this includes attachments, message threading, message timing, message tracing, ACKs, problem reports, and so forth. However, before we describe the structure and semantics of the <code>forward</code> message in detail, it's important to understand some additional routing concepts.</p>"},{"location":"routing-old/#two-dimensions","title":"Two Dimensions","text":"<p>Two dimensions of routing are relevant to DIDComm. Sometimes they are confused or conflated:</p> <ul> <li>Network routing deals with how packets flow across a digital landscape. This is the \"routing\" familiar to most technical people, and the one that will inform most assumptions they bring to the routing topic when reading the DIDComm spec for the first time.</li> <li>Cryptographic routing concerns itself with how packaging hides or reveals plaintext to participants in a delivery chain. In other words, it's about the routing of secrets rather than the routing of packets.</li> </ul> <p>The overview immediately above collapsed these two dimensions, assuming that a node relaying data is also a node decrypting. This makes for simple explanations, but it's not always a true or helpful assumption. The correspondence between these two routing dimensions can be non-trivial; a route may have ten network hops but only three cryptographic hops, and a single network hop may decrypt twice as it passes data between distinct software entities. However, simple principles explain the dynamics for each situation.</p>"},{"location":"routing-old/#mediators-and-relays","title":"Mediators and Relays","text":"<p>DIDComm routing uses two important constructs to model all varieties of network and cryptographic routing: mediators and relays.</p> <p>A mediator is a participant in routing that must be accounted for by the sender's cryptography. In other words, it is visible in the cryptographic routing dimension. It has its own keys and will deliver messages only after decrypting an outer envelope to reveal a <code>forward</code> request. It must understand DIDComm routing to do this. Many types of mediators may exist, but two important ones should be widely understood, as they commonly manifest in DID Docs:</p> <ol> <li>A service that receives messages for many agents at a single endpoint to provide herd privacy (sometimes called an \"agency\") is a mediator.</li> <li>A cloud-based agent that forwards messages to mobile devices is a mediator.</li> </ol> <p>In contrast, a relay is an entity that passes along encrypted messages without understanding or decrypting them. It's focused on network routing only.</p> <p>Like mediators, relays can be used to change the transport for a message (e.g., accept an HTTP POST, then turn around and emit an email; accept a Bluetooth transmission, then turn around and emit something in a message queue). But unlike mediators, relays can do this without understanding DIDComm. Load balancers and mix networks like TOR are important types of relay.</p> <p>Let's define mediators and relays by exploring how they manifest in a series of communication scenarios between Alice and Bob.</p>"},{"location":"routing-old/#scenario-1-direct","title":"Scenario 1: direct","text":"<p>Alice and Bob are both employees of a large corporation. They work in the same office, but have never met. The office has a rule that all messages between employees must be encrypted. They use paper messages and physical delivery as the transport. Alice writes a note, encrypts it so only Bob can read it, puts it in an envelope addressed to Bob, and drops the envelope on a desk that she has been told belongs to Bob. This desk is in fact Bob's, and he later picks up the message, decrypts it, and reads it.</p> <p></p> <p>In this scenario, there is no mediator, and no relay.</p>"},{"location":"routing-old/#scenario-2-a-gatekeeper","title":"Scenario 2: a gatekeeper","text":"<p>Imagine that Bob hires an executive assistant, Carl, to filter his mail. Bob won't open any mail unless Carl looks at it and decides that it's worthy of Bob's attention.</p> <p>Alice has to change her behavior. She continues to package a message for Bob, but now she must account for Carl as well. She take the envelope for Bob, and places it inside a new envelope addressed to Carl. Inside the outer envelope, and next to the envelope destined for Bob, Alice writes Carl an encrypted note: \"This inner envelope is for Bob. Please forward.\"</p> <p></p> <p>Here, Carl is acting as a mediator. He is mostly just passing messages along. But because he is processing a message himself, and because Carl is interposed between Alice and Bob, he affects the behavior of the sender. He is a known entity in the route.</p> <p>You may recognize this as similar to our overview example with A, B, and C. A and B correspond to Alice and Bob; C is Carl, the mediator.</p>"},{"location":"routing-old/#scenario-3-transparent-indirection","title":"Scenario 3: transparent indirection","text":"<p>All is the same as the base scenario (Carl has been fired, and is thus out of the picture), except that Bob is working from home when Alice's message lands on his desk. Bob has previously arranged with his friend Darla, who lives near him, to pick up any mail that's on his desk and drop it off at his house at the end of the work day. Darla sees Alice's note and takes it home to Bob.</p> <p></p> <p>In this scenario, Darla is acting as a relay. Note that Bob arranges for Darla to do this without notifying Alice, and that Alice does not need to adjust her behavior in any way for the relay to work.</p>"},{"location":"routing-old/#scenario-4-more-indirection","title":"Scenario 4: more indirection","text":"<p>Like scenario 3, Darla brings Bob his mail at home. However, Bob isn't at home when his mail arrives. He's had to rush out on an errand, but he's left instructions with his son, Emil, to open any work mail, take a photo of the letter, and text him the photo. Emil intends to do this, but the camera on his phone misfires, so he convinces his sister, Francis, to take the picture on her phone and email it to him. Then he texts the photo to Bob, as arranged.</p> <p></p> <p>Here, Emil and Francis are also acting as relays. Note that nobody knows about the full route. Alice thinks she's delivering directly to Bob. So does Darla. Bob knows about Darla and Emil, but not about Francis.</p> <p>Note, too, how the transport is changing from physical mail to email to text.</p> <p>To the party immediately upstream (closer to the sender), a relay is indistinguishable from the next party downstream (closer to the recipient). A party anywhere in the chain can insert one or more relays upstream from themselves, as long as those relays are not upstream of another named party (sender or mediator).</p>"},{"location":"routing-old/#more-scenarios","title":"More Scenarios","text":"<p>Mediators and relays can be combined in any order and any amount in variations on our fictional scenario. Bob could employ Carl as a mediator, and Carl could work from home and arrange delivery via George, then have his daughter Hannah run messages back to Bob's desk at work. Carl could hire his own mediator. Darla could arrange for Ivan to substitute for her when she goes on vacation. And so forth.</p>"},{"location":"routing-old/#more-traditional-usage","title":"More Traditional Usage","text":"<p>The scenarios used above are somewhat artificial. Our most familiar routing scenarios involve edge agents running on mobile devices and accessible through bluetooth or push notification, and cloud agents that use electronic protocols as their transport. Let's see how relays and mediators apply there.</p>"},{"location":"routing-old/#scenario-5-direct","title":"Scenario 5: direct","text":"<p>Alice's cloud wants to talk to Bob's cloud. Bob's cloud is listening at http://bob.com/api. Alice encrypts a message for Bob and posts it to that URL.</p> <p></p> <p>In this scenario, we are using a direct transport with neither a mediator nor a relay. This is how Alice and Bob operate in Scenario 1, and it's also equivalent to our Overview minus steps 2-5.</p> <p>When DIDComm involves only two parties, and when HTTP is convenient for both of them, this sort of direct delivery may be used. (Note that if you need n-wise, or if you need a reciprocal return route but Alice's cloud exposes no public API, this delivery scenario can present problems. More on this later.)</p> <p>Virtually the same diagram could be used for a Bluetooth or NFC or sneakernet conversation that happens offline:</p> <p></p>"},{"location":"routing-old/#scenario-6-herd-hosting","title":"Scenario 6: herd hosting","text":"<p>Let's tweak Scenario 5 slightly by saying that Bob's agent is one of thousands that are hosted at the same URL. Maybe the URL is now http://agents-r-us.com/inbox. Now if Alice wants to talk to Bob's cloud agent, she has to cope with a mediator. She wraps the encrypted message for Bob's cloud agent inside a <code>forward</code> message that's addressed to and encrypted for the agent of agents-r-us that functions as a gatekeeper.</p> <p></p> <p>This scenario is one that highlights an external mediator--so-called because the mediator lives outside the sovereign domain of the final recipient.</p>"},{"location":"routing-old/#scenario-7-intra-domain-dispatch","title":"Scenario 7: intra-domain dispatch","text":"<p>Now let's subtract agents-r-us. We're back to Bob's cloud agent listening directly at http://bob.com/agent. However, let's say that Alice has a different goal--now she wants to talk to the edge agent running on Bob's mobile device. This agent doesn't have a permanent IP address, so Bob uses his own cloud agent as a mediator. He tells Alice that his mobile device agent can only be reached via his cloud agent.</p> <p></p> <p>Once again, this causes Alice to modify her behavior. Again, she wraps her encrypted message. The inner message is enclosed in an outer envelope, and the outer envelope is passed to the mediator.</p> <p>This scenario highlights an internal mediator. Internal and external mediators introduce similar features and similar constraints; the relevant difference is that internal mediators live within the sovereign domain of the recipient, and may thus be worthy of greater trust.</p>"},{"location":"routing-old/#scenario-8-double-mediation","title":"Scenario 8: double mediation","text":"<p>Now let's combine. Bob's cloud agent is hosted at agents-r-us, AND Alice wants to reach Bob's mobile:</p> <p></p> <p>This is a common pattern with HTTP-based cloud agents plus mobile edge agents, which is the most common deployment pattern we expect for many users of self-sovereign identity. Note that the properties of the agency and the routing agent are not particularly special--they are just an external and an internal mediator, respectively.</p>"},{"location":"routing-old/#remember-routes-are-one-way-not-duplex","title":"Remember Routes are One-Way (not Duplex)","text":"<p>In all of this discussion, note that we are analyzing only a flow from Alice to Bob. How Bob gets a message back to Alice is a completely separate question. Just because Carl, Darla, Emil, Francis, and Agents-R-Us may be involved in how messages flow from Alice to Bob, does not mean they are involved in flow the opposite direction.</p> <p>Note how this breaks the simple assumptions of pure request-response technologies like HTTP, that assume the channel in (request) is also the channel out (response). Duplex request-response can be modeled with DIDComm, but doing so requires support that may not always be available, plus cooperative behavior governed by the <code>~thread</code> decorator.</p>"},{"location":"routing-old/#routing-protocol","title":"Routing Protocol","text":"<p>Now that we understand mediators and relays, how and why they might be combined in various ways, and how their presence influences delivery semantics, we can describe the actual application-level routing protocol that any DIDComm sender speaks with a destward mediator. See [Routing Protocol] in the spec.</p>"},{"location":"routing/","title":"Routing","text":"<p>Mediation is the process of relaying messages from a sender to a recipient, through one or more intermediate steps. These steps are called mediators. Mediators allow for reliability in message delivery and enhanced privacy for network-challenged agents. </p> <p>Different types of mediators exist, thought the most common is an Inbound Mediator. Other mediator types are discussed in Advanced Topics.</p>"},{"location":"routing/#why-do-we-need-mediation","title":"Why Do We Need Mediation?","text":"<p>To understand why mediators exist, we must first distinguish between different types of agents. Two primary kinds of agents exist, cloud agents and edge agents. Cloud agents, as their name implies, exist in the cloud. A primary characteristic of these agents is a fixed endpoint for communication. Edge agents include devices such as smartphones, personal computers, and other mobile devices. Such devices have ephemeral addresses and cannot be reliably communicated with at a specific endpoint.</p> <p>Mediators primarily exist to bridge the gap between cloud agents and edge agents. A mediator has a persistent, fixed endpoint that can be accessed by edge agents and cloud agents alike. Edge agents who are granted mediation can report the mediator's information to other agents. These other agents can then send messages to the mediator's fixed endpoint, and the mediator will either pass them along to the mediated client or hold on to them until the client picks them up. </p>"},{"location":"routing/#sidebar-mediator-vs-relay","title":"Sidebar: Mediator vs. Relay","text":"<p>This concept of mediation has existed for as long as DIDComm has. Historically, agents that relayed messages have been referred to as mediators. However, the term \"mediator\" implies a level of authority in a given interaction, and these agents have no inherent authority. The term \"relay\" has relatively recently been proposed as a replacement, more accurately capturing the unopinionated, unauthoritative nature of these agents.  In a future version of the DIDComm standard, \"relay\" will likely replace \"mediator\" as the official term. However, \"mediator\" has been used here to avoid confusion with the current specification.</p>"},{"location":"routing/#how-does-mediation-work","title":"How Does Mediation Work?","text":"<p>As we've mentioned mediators typically exist to serve as a stand-in for a missing fixed endpoint for edge agents. Inbound relays can exist as public entities, serving any edge agent who requests mediation, or they can be configured to only relay messages for approved edge agents.</p>"},{"location":"routing/#inbound-mediation-flow","title":"Inbound Mediation Flow","text":""},{"location":"routing/#the-forward-message","title":"The Forward Message","text":"<p>The core of inbound mediation is the <code>forward</code> message. Simply put, forward messages are wrappers, addressed and encrypted to mediators, with an additional payload that is encrypted for the ultimate recipient. This allows messages of any type to be passed to and through a mediator, without a strong degree of trust in the mediator. The mediator is incapable of reading the encrypted payload.  Mediators can be configured to rewrap messages. In this case, rather than delivering the original (opaque) payload directly to the recipient, they can wrap the payload in another <code>forward</code> message. This preserves the original size of the message received by the mediator, but more importantly, it allows mediators to be chained in arbitrary lengths; as long as all the mediators know to rewrap messages, and which mediator is next in the chain, a message can pass through any number of mediators until it arrives at its final destination.</p>"},{"location":"routing/#advanced-mediator-topics","title":"Advanced Mediator Topics","text":""},{"location":"routing/#duplicate-mediators","title":"Duplicate Mediators","text":""},{"location":"routing/#for-reliability","title":"For Reliability","text":"<p>Mediators are designed to improve the reliability of message delivery, but like all software deployments, there's always risk of downtime. One way to mitigate that risk and to help insure that messages arrive to your agent promptly is to set up multiple mediators.  A mobile agent can configure arbitrarily many mediators to relay messages for it. Invitations can be configured with multiple endpoints, arranged in order of preference, which are then reported to third parties like normal. Connections to your agent should attempt to deliver their messages to the mediator you specify as your primary endpoint. However, if the message is undeliverable, due to downtime in that mediator, they can try again, sending the message to the other mediators, according to the specified preference, until the message is deliverable. </p>"},{"location":"routing/#for-message-tracking","title":"For Message Tracking","text":"<p>It may be desirable to know where messages are coming from, and one way to do that it by setting up multiple mediators. If you have multiple mediators set up, you can keep track of which messages arrive from which mediator.  As an example, you might have one mediator set up for high-priority connections, which you enable live delivery from as often as you are able, and a second mediator for lower priority connections or messages, and you only poll for messages occasionally, at some predetermined interval.</p>"},{"location":"routing/#additional-types-of-mediators","title":"Additional Types of Mediators","text":""},{"location":"routing/#outbound-mediator","title":"Outbound Mediator","text":"<p>Outbound mediators exist to obscure the sender of a message. A sender can send a message to an outbound mediator, which then actively sends along the message to the intended recipient. The recipient then sees the outbound mediator as the sender of the message, rather than the actual sender.</p>"},{"location":"routing/#hidden-mediator","title":"Hidden Mediator","text":"<p>A hidden mediator is a mediator that is unknown to the sender. Inbound mediators are known to be mediators, and thus senders will wrap messages in <code>forward</code> messages. With a hidden mediator, senders will simply pack messages to the hidden mediator directly, not wrapping their messages as <code>forward</code> messages.  This requires a close coupling of mediator-to-agent and a high degree of trust. Typically, a hidden mediator will be deployed with another agent's deployment. This can be useful to bypass issues with exposing endpoints of agents behind firewalls. Hidden mediators can also be instantiated between an inbound mediator and an agent that is incapable of polling for messages from said inbound mediator, allowing such an agent to use an inbound mediator. </p>"},{"location":"scrapbook/","title":"Community Presentations","text":"<p>Here is a chronological list of DIDComm v2 presentations, products, services, efforts, and more. Feel free to submit new links or updates here.</p>"},{"location":"scrapbook/#chronological-scrapbook-of-didcomm-v2-presentations-usage-efforts-and-more","title":"Chronological scrapbook of DIDComm v2 presentations, usage, efforts, and more","text":"<ul> <li>Agent Development - Nessus DIDComm v1 and v2 PoC</li> <li>Video Presentation - Sam Curren and Alex Andrei present DIDComm v2 to the Open Wallet Foundation</li> <li>Blog - Daniel Hardman compares/contrasts OIDC, CHAPI, DWN, and DIDComm</li> <li>Live Service - RootsID DIDComm v2 mediator was meant to support mobile DIDComm v2 agents, but is also useful as a test DIDComm v2 interaction/interop service.</li> <li>Video Presentation - Daniel Hardman presents DIDComm v2 to the W3C</li> <li>Agent Development - Veramo has added some DIDComm v2 support and encourages contributions</li> <li>Agent Development - Aries framework javascript (AFJ) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions</li> <li>Agent Development - Aries cloud agent python (ACA-Py) DIDComm v1 impl is actively adapting to DIDComm v2 and encourages contributions</li> </ul>"},{"location":"startConnection/","title":"startConnection","text":""},{"location":"startConnection/#starting-using-and-ending-a-didcomm-connection","title":"Starting, using and ending a DIDComm connection","text":"<p>This tutorial shows how Alice can invite Bob to start a connection, send and receive encrypted messages using an https transport, and end the relationship.</p> <p>The code relies on DIDComm Python and Peerdid Python libraries from SICPA.</p> <p>The code in the following sections can be executed in a single python file or executed online in this Binder interactive Jupyter notebook</p>"},{"location":"startConnection/#step-1-imports","title":"Step 1: Imports","text":"<p>First, we need to import all required functions, clases and types from <code>didcomm</code> and <code>peerdid</code> libraries.</p> <pre><code>import json\nimport base64\nimport qrcode\nimport requests\nimport matplotlib.pyplot as plt\nfrom typing import Optional, List\nfrom didcomm.common.types import DID, VerificationMethodType, VerificationMaterial, VerificationMaterialFormat\nfrom didcomm.did_doc.did_doc import DIDDoc, VerificationMethod, DIDCommService\nfrom didcomm.did_doc.did_resolver import DIDResolver\nfrom didcomm.message import Message, FromPrior\nfrom didcomm.secrets.secrets_resolver_demo import SecretsResolverDemo\nfrom didcomm.unpack import unpack, UnpackResult\nfrom didcomm.common.resolvers import ResolversConfig\nfrom didcomm.pack_encrypted import pack_encrypted, PackEncryptedConfig, PackEncryptedResult\nfrom peerdid.core.did_doc_types import DIDCommServicePeerDID\nfrom didcomm.secrets.secrets_util import generate_x25519_keys_as_jwk_dict, generate_ed25519_keys_as_jwk_dict, jwk_to_secret\nfrom peerdid import peer_did\nfrom peerdid.did_doc import DIDDocPeerDID\nfrom peerdid.types import VerificationMaterialAuthentication, VerificationMethodTypeAuthentication, VerificationMaterialAgreement, VerificationMethodTypeAgreement, VerificationMaterialFormatPeerDID\n</code></pre>"},{"location":"startConnection/#step-3-resolvers","title":"Step 3: Resolvers","text":"<p>In this step we add two Resolvers needed by DIDComm and the libraries:</p> <p>Secret resolver:</p> <p>This sample code needs a storage to keep the generated key pair secrets. It will then be referenced by the library as a <code>secrets_resolver</code>. We can instantiate it as follows: <code>secrets_resolver = SecretsResolverDemo()</code> Note that the <code>SecretsResolverDemo</code> simply stores the keys in a text file named <code>secrets.json</code>. As you've just realized, this secret storage is anything but secure. Keep in mind that securing keys is of utmost importance for a self-sovereign identity; never use it in production.</p> <p>DID Resolver:</p> <p>DIDComm only works if your code knows how to resolve DIDs to DID documents. There are various libraries that provide that feature. For example, the Universal Resolver can be used. In this walk-through, we'll provide a simple stub that minimizes dependencies and keeps things as simple as possible. Click here for full example where you'll find the code that do the trick.</p>"},{"location":"startConnection/#step-3-out-of-band-invitation","title":"Step 3: Out of Band Invitation","text":"<p>Using our <code>create_peer_did</code> helper function, Alice will create a DID Peer to be shared in the OOB invitation. Since an OOB invitation is unencrypted and may be observed by another party, this DID should not be considered private and must be rotated later for privacy. Alice DID also contains a <code>service</code> part that tells Bob the <code>serviceEndpoint</code> where she accepts messages. In this case Alice provides an <code>https</code> endpoint. For other cases additional Routing may be required.</p> <pre><code>alice_did_oob = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\")\nprint(\"Alice's OOB DID:\", alice_did_oob)\n</code></pre> <pre><code>Alice's OOB DID: did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ\n</code></pre> <p>Remember that while creating this DID, our helper function also stores the private keys in the <code>secrets_resolver</code>. In a real implementation, Alice will have her own secure store in her own wallet, and Bob will have a separated secure store in his own wallet.</p> <p>Also, those Peer DIDs can be resolved into DID documents that contain the Authentication, Agreement public keys, and the Service details.</p> <p>With this DID Peer, Alice can create an Out Of Band invitation message as follows:</p> <pre><code>oob_mesage = {\n  \"type\": \"https://didcomm.org/out-of-band/2.0/invitation\",\n  \"id\": \"unique-id-24160d23ed1d\",\n  \"from\": alice_did_oob,\n  \"body\": {\n    \"goal_code\": \"connect\",\n    \"goal\": \"Start relationship\",\n    \"accept\": [\n      \"didcomm/v2\",\n      \"didcomm/aip2;env=rfc587\"\n    ],\n  }  \n}\n</code></pre> <p>You can see that the <code>type</code> of the massage was declared as \"https://didcomm.org/out-of-band/2.0/invitation\" and Alice OOB DID was included in the <code>from</code> header. Also, remember that the unique <code>id</code> declared in the message must be used in the parent thread ID <code>pthid</code> in Bob's following response.</p> <p>The message has to be whitespaced removed and encoded using URL Base 64.</p> <pre><code>plaintext_ws_removed = json.dumps(oob_mesage).replace(\" \", \"\")\nencoded_plaintextjwm = base64.urlsafe_b64encode(plaintext_ws_removed.encode(\"utf-8\"))\nencoded_text = str(encoded_plaintextjwm, \"utf-8\").replace(\"=\",\"\")\n</code></pre> <p>Finally, we put the encoded message in a URL that can be emailed to Bob:</p> <pre><code>oob_url = \"https://example.com/path?_oob=\"+encoded_text\nprint(oob_url)\n</code></pre> <p>https://example.com/path?_oob=eyJ0eXBlIjoiaHR0cHM6Ly9kaWRjb21tLm9yZy9vdXQtb2YtYmFuZC8yLjAvaW52aXRhdGlvbiIsImlkIjoidW5pcXVlLWlkLTI0MTYwZDIzZWQxZCIsImZyb20iOiJkaWQ6cGVlcjoyLkV6NkxTaDZybWdXaEFzdnlZUm81bW5LVHVadFNrTWI5a2VpZHFER1V5Z3JQRDlrZ0suVno2TWtzcXRkWHVUYXI0Z2pQVE1HNnRFZVBMOWRGSEJjNnM3bUp4UWs4Y0w5OGhvai5TZXlKcFpDSTZJbTVsZHkxcFpDSXNJblFpT2lKa2JTSXNJbk1pT2lKb2RIUndjem92TDNkM2R5NWxlR0Z0Y0d4bExtTnZiUzloYkdsalpTSXNJbUVpT2xzaVpHbGtZMjl0YlM5Mk1pSmRmUSIsImJvZHkiOnsiZ29hbF9jb2RlIjoiY29ubmVjdCIsImdvYWwiOiJFc3RhYmxpc2hjb25uZWN0aW9uIiwiYWNjZXB0IjpbImRpZGNvbW0vdjIiLCJkaWRjb21tL2FpcDI7ZW52PXJmYzU4NyJdfX0</p> <p>Other common option to share the OOB message is by creating a QR code that Bob can scan:</p> <pre><code>image = qrcode.make(oob_url)\nplt.imshow(image , cmap = 'gray')\n</code></pre> <p>-- INSERT_QR_CODE_IMAGE_HERE --</p>"},{"location":"startConnection/#step-4-receiving-the-oob-message","title":"Step 4: Receiving the OOB message","text":"<p>Once Bob receives the email or scan the QR code, he can easily decode it and read Alice's message:</p> <pre><code>received_msg_encoded = oob_url.split(\"=\")[1]\nreceived_msg_decoded = json.loads(str(base64.urlsafe_b64decode(received_msg_encoded + \"==\"), \"utf-8\"))\nprint(received_msg_decoded)\n</code></pre> <pre><code>{'type': 'https://didcomm.org/out-of-band/2.0/invitation', 'id': 'unique-id-24160d23ed1d', 'from': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'body': {'goal_code': 'connect', 'goal': 'Establishconnection', 'accept': ['didcomm/v2', 'didcomm/aip2;env=rfc587']}}\n</code></pre> <p>After Bob checks the invitation, he is able to prepare a response back. Since Bob has not established a connection with Alice before, he needs to create a DID peer to be used in all communications with Alice. This DID Peer will be dedicated to Alice and only Alice. If Bob needs to comunicate with someone else, he should create a new DID Peer.</p> <pre><code>bob_did = await create_peer_did(1,1, service_endpoint=\"https://www.example.com/bob\")\nprint(\"Bob's DID:\", bob_did)\n</code></pre> <pre><code>Bob's DID: did:peer:2.Ez6LSfHCNnrXfs6mPio69GbvoL6szGxCXcL3tf8kLDQDYsncm.Vz6MkiDnmWvdnKoFrn7fDfXVykbRmW7MuEyMp1ZcnZu1KvUZL.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0\n</code></pre> <p>Bob's response will depends on the <code>goal</code> code of the invitation received. Here is a response message as an example:</p> <pre><code>bob_response_message = Message(\n    body = {\"msg\": \"Hi Alice\"},\n    id = \"unique-id-263e24a422e\",\n    pthid = received_msg_decoded[\"id\"],\n    type = \"my-protocol/1.0\",\n    frm = bob_did,\n    to = [received_msg_decoded[\"from\"]]\n)\n</code></pre> <p>Note that the message includes an <code>id</code> that is mandatory and has to be unique to Bob, but also includes the parent thread ID <code>pthid</code> matching Alice's message <code>id</code>.</p> <p>Also includes a <code>type</code>, also mandatory, that points to the protocol identifier in conformance with the <code>goal</code> of the invitation. The <code>body</code> contains the actual message in a structured way associated by our <code>my-protocol/1.0</code>. Attributes <code>from</code> and <code>to</code> are optional. Beware that in the code above the property <code>from</code> was replaced by <code>frm</code> due to a conflict of reserved words in Python; the conversion to the correct property (<code>from</code>) is handled internally by the library.</p> <p>The final encrypted and packed message can be generated with this code:</p> <pre><code>bob_packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = bob_response_message,\n    frm = bob_did,\n    to = alice_did_oob,\n    sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n</code></pre>"},{"location":"startConnection/#step-5-sending-the-message-to-alice","title":"Step 5: Sending the message to Alice","text":"<p>From the received message, Bob can get and resolve Alice's DID into a DID Document. He can use a Universal Resolver or just our helper class as we use in the following lines:</p> <pre><code>alice_did_doc = json.loads(peer_did.resolve_peer_did(received_msg_decoded[\"from\"]))\nprint(alice_did_doc)\n</code></pre> <pre><code>{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'authentication': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj', 'type': 'Ed25519VerificationKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj'}], 'keyAgreement': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK', 'type': 'X25519KeyAgreementKey2020', 'controller': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ', 'publicKeyMultibase': 'z6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK'}], 'service': [{'id': 'did:peer:2.Ez6LSh6rmgWhAsvyYRo5mnKTuZtSkMb9keidqDGUygrPD9kgK.Vz6MksqtdXuTar4gjPTMG6tEePL9dFHBc6s7mJxQk8cL98hoj.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ#didcommmessaging-0', 'type': 'DIDCommMessaging', 'serviceEndpoint': 'https://www.example.com/alice', 'accept': ['didcomm/v2']}]}\n</code></pre> <p>From the DID Document, Bob can understand how Alice is expecting to receive messages. In this case, he gets Alice's endpoint:</p> <pre><code>alice_endpoint = alice_did_doc[\"service\"][0][\"serviceEndpoint\"]\nprint(alice_endpoint)\n</code></pre> <p>https://www.example.com/alice</p> <p>Using an <code>https</code> transport Bob can simply <code>POST</code> the message to the endpoint with the message in the <code>body</code> and the media type header set to <code>application/didcomm-encrypted+json</code>.</p> <pre><code>headers = {\"Content-Type\": \"application/didcomm-encrypted+json\"}\nresp = requests.post(alice_endpoint, headers=headers, data = bob_packed_msg.packed_msg)\n</code></pre> <p>In a real scenario, you will receive a success http response code in the range of 2XX such as a 202. This case will fail since it's not a real endpoint.</p>"},{"location":"startConnection/#step-5-alice-responding-back-to-bob-with-a-rotated-did","title":"Step 5: Alice responding back to Bob with a rotated DID","text":"<p>Alice has finally received a response back from Bob at her endpoint. The encrypted message is in the body of the POST request that can be unpacked and decrypted with the following code:</p> <pre><code>bob_unpack_msg = await unpack(\n    resolvers_config=ResolversConfig(\n        secrets_resolver=secrets_resolver,\n        did_resolver=DIDResolverPeerDID()\n    ),\n    packed_msg=bob_packed_msg.packed_msg\n)\n</code></pre> <p>Note that we also passed the resolver config as before.</p> <p>Finally, Alice can see Bob's response message:</p> <pre><code>print(bob_unpack_msg.message.body[\"msg\"])\n</code></pre> <pre><code>Hi Alice\n</code></pre> <p>And also she can get Bob's DID Peer:</p> <pre><code>print(bob_unpack_msg.message.frm)\n</code></pre> <pre><code>did:peer:2.Ez6LSmYH5Lttu3WFRCJuVyg8RXBD7ncvL5S93ojKUhan2Mhgs.Vz6MkmbHcPTycTGg23jsJK3diDnp4v5tt8hNnvbGWCzs3Trsv.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9ib2IiLCJhIjpbImRpZGNvbW0vdjIiXX0\n</code></pre> <p>and from Bob's DID, she can resolve the DID Document and get Bob's service endpoint:</p> <pre><code>bob_did_doc = json.loads(peer_did.resolve_peer_did(bob_unpack_msg.message.frm))\nbob_endpoint = bob_did_doc[\"service\"][0][\"serviceEndpoint\"]\nprint(bob_endpoint)\n</code></pre> <p>https://www.example.com/bob</p> <p>Now Alice is able to respond back to Bob's. However, in order to keep DID Peers private between them, Alice must replace the DID used in the Out of Band message by a new one. That process is call DID rotation.</p> <p>A DID is rotated by sending a message to Bob including the <code>from_prior</code> header containng a JWT with the new DID in the <code>sub</code> and the prior DID in the <code>iss</code> fields. First, she need to create the new DID Peer:</p> <pre><code>alice_did_new = await create_peer_did(1, 1, service_endpoint=\"https://www.example.com/alice\")\nprint(\"Alice's NEW DID:\", alice_did_new)\n</code></pre> <pre><code>Alice's NEW DID: did:peer:2.Ez6LSnn1bdY7Zy5WLuXxMQWEpDb2o9L9g8fW9Z2NWdASTAAKd.Vz6MkqFwmMSecezdhHHGMQJPEpjkoSFNVBQRnQG15P1VbgJsN.SeyJpZCI6Im5ldy1pZCIsInQiOiJkbSIsInMiOiJodHRwczovL3d3dy5leGFtcGxlLmNvbS9hbGljZSIsImEiOlsiZGlkY29tbS92MiJdfQ\n</code></pre> <p>Then, with the help of the library she can easily creat the <code>from_prior</code> header. More details on how to make the JWT can be found in Chapter 5.3 of DIDComm Messaging Specification</p> <pre><code>from_prior = FromPrior(iss=alice_did_oob, sub=alice_did_new)\n\nalice_rotate_did_message = Message(\n    body = {\"msg\": \"I'm rotating my peer DID\"},\n    id = \"unique-id-293e9a922e\",\n    type = \"my-protocol/1.0\",\n    frm = alice_did_new,\n    to = [bob_unpack_msg.message.frm],\n    from_prior = from_prior\n)\n</code></pre> <p>As in previous steps, Alice will encrypt and pack the message, and POST it to Bob's endpoint:</p> <pre><code>alice_packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = alice_rotate_did_message,\n    frm = alice_did_new,\n    to = bob_unpack_msg.message.frm,\n    sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n\nheaders = {\"Content-Type\": \"application/didcomm-encrypted+json\"}\nresp = requests.post(bob_endpoint, headers=headers, data = alice_packed_msg.packed_msg)\n</code></pre> <p>Bob will receive the message in his endpoint, unpack and decrypt, and get the new Alice's DID. He must store Alice's new DID and use it in subsequent communications.</p>"},{"location":"startConnection/#step-6-whats-next-protocols","title":"Step 6: What's next --&gt; Protocols","text":"<p>Now Alice and Bob have a private way to communicate. This communication channel can be used whenever they need. Normally, messages passed back and forth will follow a protocol that can be understood by both. We won't cover protocols in this tutorial. You can read more about protocols in Chapter 9 of the DIDComm Messaging specification</p>"},{"location":"startConnection/#step-7-ending-a-relationship","title":"Step 7: Ending a relationship","text":"<p>Alice and Bob can use the channel forever. They know how to pass messages and even how to rotate a DID if needed. If for any reason, Alice (or Bob) need to end the relationship, she can simply send a message rotating the DID to nothing. That is achieved by ommiting the <code>sub</code> in the <code>from_prior</code> and sending the message without a <code>from</code> attribute of the message as it's shown below:</p> <pre><code>from_prior_end = FromPrior(iss=alice_did_new, sub=None)\n\nalice_end_message = Message(\n    body = {\"msg\": \"I'm finishing this relationship :(\"},\n    id = \"unique-id-25359a955e\",\n    type = \"my-protocol/1.0\",\n    to = [bob_unpack_msg.message.frm],\n    from_prior = from_prior_end\n)\n\nalice_end_packed_msg = await pack_encrypted(\n    resolvers_config = ResolversConfig(\n        secrets_resolver = secrets_resolver,\n        did_resolver = DIDResolverPeerDID()\n    ),\n    message = alice_end_message,\n    to = bob_unpack_msg.message.frm,\n   sign_frm = None,\n    pack_config = PackEncryptedConfig(protect_sender_id=False)\n)\n</code></pre>"},{"location":"threading/","title":"Threading","text":"<p>DIDComm's threading mechanism enables referencing individual messages, the sets of messages that constitute a logically independent interaction (a \"run\" or \"instance\" of a protocol), or even the hierarchies of messages that model nested and recursive workflows. This helps with troubleshooting, debugging, error reporting, resend logic, interactions across more than two parties, and patterns of communication that are more flexible or asynchronous than simple request+response.</p> <p>Some context about the intent and best practices for these features may be helpful:</p> <ul> <li>For cybersecurity reasons, the <code>id</code> properties of related messages are intended not to bear any resemblance to one another; <code>id</code> values are expected to be opaque and will likely cause additional issues if they include overloaded semantics that are unique to a particular implementation. This lack of a detectable relationship should be characteristic of <code>id</code> values for messages that stand in sequence to one another, as well as the <code>id</code> properties of <code>forward</code> messages seen by mediators vis-a-vis the <code>id</code> of the innermost plaintext messages they carry.</li> </ul>"},{"location":"threading/#threads","title":"Threads","text":"<p>Like threads in email, a thread in DIDComm intends to model a discrete interaction. For protocols that have a beginning and end (e.g., exchanging credentials, playing a game of chess, making a payment), a DIDComm thread maps exactly onto the sequence of messages that embody one such interaction; when a new interaction like this starts, the parties are expected to impute a new thread to the context.</p> <p>However, some DIDComm protocols are not obviously discrete. An example of this might be a human-friendly chat; humans don't necessarily perceive crisp interaction boundaries around any given subset of the messages they trade back and forth. In such cases, a thread might map to a topic, a unit of time, or something else. Applications can structure the thread construct in whatever way makes sense to the implementers, but MUST describe the threading assumptions of the protocol in the protocol's documentation.</p>"},{"location":"threading/#parent-threads","title":"Parent Threads","text":"<p>Parent threads and child threads do not necessarily represent threads of execution or concurrency; they only represent logically separable sequences of messages. A parent thread can trigger multiple child threads, whuch could cascade to multiple levels of nested message threads (for example, issuing a credential triggers payment, which in turn triggers feature discovery). Parent threads and child threads do not have a simple containment or ownership relationship. By definition, a parent is only a trigger \u2014 not necessarily a controller or stakeholder. A parent thread has no guarantees about its lifecycle and could end before or after any of its child threads. Parent and child threads also can interact or share data, but are not required to do so. (How they do so is out of scope in this spec, but see Coprotocols for one way to approach this.)</p>"},{"location":"threading/#parent-and-child-examples","title":"Parent and Child Examples","text":"<p>Creating a connection is a classic interaction that lends itself to a parent-child paradigm. Alice and Bob rarely connect just to connect; usually they connect so they can conduct some type of business. In such situations, the connection protocol is a parent thread, and whatever business they then conduct becomes a child.</p> <p>Reporting and resolving errors and warnings is also a good use case for parent and child threads. It is true that problems can be communicated in specialized messages of an individual protocol; some protocols may make this choice. However, problems are often the gateway to deeper troubleshooting or even support tickets, which are complex workflows in their own right. Also, robust mechanisms for logging, analyzing, and reacting to problems may be reusable in many workflows. For this reason, it is recommended to model problem reporting as a child protocol, with an arbitrarily complex thread of messages as child to the parent workflow that triggered them. See Reporting and Handling Problems for more info.</p> <p>Sometimes the parent of a thread is not known, or is so independent of its child as to be irrelevant. If Alice and Bob connected three years ago, each new interaction that they begin doesn't need to declare a <code>pthid</code> that references the original interaction that connected them. Declare a parent relationship for a thread when it is likely to be useful.</p>"},{"location":"threading/#message-uris","title":"Message URIs","text":"<p>It's generally considered this functionality will be combined with JSPath or JS Pointer so individual elements of messages may also be hyperlinked. For a good idea of the concepts that we'd like to enable with this capability, see Linkable Message Paths.</p>"},{"location":"timeouts/","title":"Timeouts","text":"<p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"whatsnew/","title":"Whatsnew","text":""},{"location":"whatsnew/#whats-new","title":"What's New?","text":"<p>The version of DIDComm incubated in the Hyperledger Aries community is referred to as Version 1 (V1). This spec describes the next version, referred to as Version 2 (V2). This section will describe the changes between V1 and V2, useful to members of the Aries community.</p>"},{"location":"whatsnew/#summary-of-changes","title":"Summary of Changes","text":"<ul> <li>Formalization of methods used in V1</li> <li>JWM based envelope</li> <li>ECDH-1PU standardized form of AuthCrypt</li> <li>Both DID and key in each message</li> <li>Special Handling of Peer DIDs eliminated</li> <li>Message structure split between 'headers' and body.</li> <li>No AnonCrypt encryption method.</li> </ul>"},{"location":"whatsnew/#practical-changes","title":"Practical Changes","text":"<p>The list of changes above leads to practical changes in how DIDComm is used.</p>"},{"location":"whatsnew/#did-exchange-not-needed","title":"DID Exchange not needed","text":"<p>Each message contains both the sender key (used in the encryption layer), and the sender's DID. The exchange of DIDs that occurs via the DID Exchange Protocol used in V1 occurs in each message that is transferred. The important step of rotating DIDs is accomplished via the <code>from_prior</code> header that travels alongside any protocol message. These features make the DID Exchange Protocol redundant.</p> <p>One side effect of the DID Exchange Protocol in V1 was that you confirmed the validity of the DID with a round trip to the other party. Many protocols will provide this assurance via the flow of the protocol prior to the point where round-trip testing is required. When this round-trip is desired prior to the beginning of a protocol, a round trip with another protocol (such as Trust Ping or Feature Discovery) can provide the same assurance.</p>"},{"location":"whatsnew/#special-handling-of-peer-dids-eliminated","title":"Special Handling of Peer DIDs eliminated","text":"<p>DIDComm V1 defined special handling of Peer DIDs, making it very optimized for usage with Peer DIDs. However this made it less obvious how other DID methods could be used with DIDComm. DIDComm V2 eliminated special handling of Peer DIDs, making handling of all DIDs equal from the perspective of the DIDComm spec. This creates a more distinct separation between how DIDs are used (defined by DID Core and specific DID method) and how to securely communicate using DIDs (defined by DIDComm spec).</p> <p>The new <code>to</code> and <code>from</code> attributes inside a DIDComm message allow for query parameters to be included on a DID. Using the query parameters you can exchange additional information without using custom fields. DID methods indicate how query parameters can be used to pass state information. For example, the Peer DID method defines the usage of the <code>initial-state</code> query parameter to pass all information needed to construct a DIDDoc in a single field.</p>"},{"location":"whatsnew/#process-from-headers-prior-to-protocol-processing","title":"Process From Headers prior to Protocol Processing","text":"<p>Relationship changes in V1 were handled inside the DID Exchange Protocol. In V2, relationship changes including discovery and rotation are handled in message headers.</p> <p>In V2, messages must evaluate the <code>from</code> and <code>from_prior</code> headers of every message prior to beginning the protocol message processing.</p>"},{"location":"whatsnew/#no-technical-difference-between-ephemeral-mode-and-full-mode","title":"No technical difference between Ephemeral Mode and Full Mode","text":"<p>Ephemeral mode in V1 was a method of passing messages without first performing an exchange of DIDs. Given that we no longer have a need to perform an exchange of DIDs prior to passing messages of another protocol, we no longer need to designate a mode for ephemeral interactions.</p>"},{"location":"whatsnew/#message-level-decorators-now-represented-as-headers","title":"Message Level Decorators now represented as Headers","text":"<p>The adjusted structure of DIDComm messages now represents message level decorators as message headers. An example includes <code>thid</code>.</p>"},{"location":"whatsnew/#return-route-moved-to-extension","title":"Return-Route Moved to Extension","text":"<p>The return-route mechanism has been moved to an extension due to it's limited application. This mechanism is useful in last-mile message delivery for mobile devices and agents without a public endpoint.</p>"},{"location":"why/","title":"Why DIDComm?","text":"<p>This guide contains concepts, explanations, and important considerations for those building DIDComm capable systems.</p> <p>Note: This book is a community-supported resource, under regular improvement. Corrections and contributions are welcome at our GitHub Repo.</p>"},{"location":"workinggroups/","title":"Working Groups","text":""},{"location":"workinggroups/#didcomm-users-group","title":"DIDComm Users Group","text":"<p>The DIDComm Users Group is focused on developing protocols and applications using the DIDComm v2 Specification. Activity focuses on weekly calls, the discord channel, and github issues.</p> <p>All are invited to attend and participate. DIF Membership is not required.</p> <p>User Group Details</p>"},{"location":"workinggroups/#didcomm-specification-working-group","title":"DIDComm Specification Working Group","text":"<p>The DIDComm Specification Working Group is focused on development of the spec and related topics. This group does require DIF Membership, and meetings are IPR Protected. This group meets less frequently for maintenance activities surrounding the latest version of the spec.</p> <p>Working Group Details</p>"},{"location":"applications/","title":"Technology Verticals","text":"<p>DIDComm can be used for many things. Some of these applications can be grouped into technology verticals, described below and detailed on related pages.</p>"},{"location":"applications/#verifiable-credentials","title":"Verifiable Credentials","text":"<p>DIDComm provides an excellent way to coordinate Verifible Credential activities between parties. </p>"},{"location":"applications/#human-communication","title":"Human Communication","text":"<p>Enables human-oriented communication between parties leveraging the security and privacy of DIDComm. Often used in a supporting role alongside other protocols.</p>"},{"location":"applications/#additional-protocol-development","title":"Additional Protocol Development","text":"<p>DIDComm supports the development of additional protocols in any technology vertical. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.</p>"},{"location":"applications/human_communication_tech_vertical/","title":"DIDComm for Human Communication","text":"<p>DIDComm Protocols for Human Communication allow for the interactions between two parties using human focused communication.</p>"},{"location":"applications/human_communication_tech_vertical/#related-protocols","title":"Related Protocols","text":"<p>Note that DIDComm allows the use of various protocols between parties. These human oriented communication protocols blend well with protocols of many other types, including but not limited to Verifiable Credentials and other forms of data exchange.</p>"},{"location":"applications/human_communication_tech_vertical/#basic-message","title":"Basic Message","text":"<p>Allows bidirectional chat based communication. Either party can send messages. Supports language indication to allow for translation. Purposefully simple.</p>"},{"location":"applications/human_communication_tech_vertical/#question-answer","title":"Question Answer","text":"<p>Facilitates the asking and answering of fixed answer questions. This is typically between a human and a service, allowing the service to customize flows based on user selections.</p>"},{"location":"applications/human_communication_tech_vertical/#action-menu","title":"Action Menu","text":"<p>Provides a menu and basic form interface between parties. This is typically between a human and a service, allowing the human to be aware of and invoke process flows provided by the service.</p>"},{"location":"applications/human_communication_tech_vertical/#user-profile","title":"User Profile","text":"<p>Facilitates the sharing of user profile information between parties. This is typically between a human and a service, allowing the human to be aware of and consent to sharing basic profile information.</p>"},{"location":"applications/human_communication_tech_vertical/#media-sharing","title":"Media Sharing","text":"<p>Allows birectional sharing of large media files between parties. The protocol shares file metadata by reference to offload file processing workloads (upload/storage/download) from the protocol.</p>"},{"location":"applications/human_communication_tech_vertical/#additional-protocol-development","title":"Additional Protocol Development","text":"<p>DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.</p>"},{"location":"applications/vc_tech_vertical/","title":"DIDComm for Verifiable Credentials","text":"<p>DIDComm Protocols for Verifiable Credentials allow for the issuance, presentation, and management of Verifiable Credentials.</p>"},{"location":"applications/vc_tech_vertical/#related-protocols","title":"Related Protocols","text":"<p>Note that DIDComm allows the use of various protocols between parties. Many applications of Verifiable Credentials are improved with the inclusion of  other protocols. Sending a human readable message about credential actions may improve the user experience, for example.</p>"},{"location":"applications/vc_tech_vertical/#out-of-band-oob","title":"Out of Band (OOB)","text":"<p>Credentials are often Issued or Presented in association with the scan of a QR Code. The OOB Protocol contains the details of how those QR codes are created, and how they can facilitate an interaction flow directly into the desired protocol.</p>"},{"location":"applications/vc_tech_vertical/#issue-credential","title":"Issue Credential","text":"<p>Issue Credential coordinates the issuance of a credential. The protocol supports simple flows and complex flows, and supports any credential type, including those that need some back and forth interaction before credential issuance. Credential issuance may be initiated by either party in the interaction.</p>"},{"location":"applications/vc_tech_vertical/#present-proof","title":"Present Proof","text":"<p>Present Proof coordinates the presention of a Verifiable Credential Proof Presentation. It supports any credential type within the same protocol. Present proof may be initiated by either party in an interaction.</p>"},{"location":"applications/vc_tech_vertical/#revocation-notification","title":"Revocation Notification","text":"<p>Supports notification to the credential holder that a credential they were previously issued has been revoked. This is initiated from the issuer at some time after credential issuance. Receiving such a notification can improve the user experience for a user in a revocation experience, allowing them to know of the revocation prior to an attempt to present the credential.</p>"},{"location":"applications/vc_tech_vertical/#additional-protocol-development","title":"Additional Protocol Development","text":"<p>DIDComm supports the development of additional protocols. Creating a new protocol and promoting it can add useful funcationality into the ecosystem. Support for these protocols can be detected with the Discover Features protocol when communicating with other software.</p>"}]}